\chapter{Cassandra Benchmark Study}

\label{Chapter4}
\label{Cassandra Benchmark Study}

%(CONTRIBUTION 1 â€“ Design and implement a methodology to evaluate a distributed NoSQL database in IoT)
%4.1          Overview 
%4.2          Bandwidth testing 
%4.3          Platform testing
%4.4          Network configuration testing

\section{Overview}
This section describes the results of the testing.
\section{Bandwidth testing}
\section{Platform testing}

\begin{figure}[h]
\includegraphics[width=15cm]{Figures/wla.png}

\caption{Workload A: Reading and Updating}

\label{fig:wla}
\end{figure}

This is the initial test to as closely match the methodology of \cite{Abramova2014TestingCassandra}.  These are Ubuntu 2GB \gls{ram} virtual machines on a Lenovo Thinkpad.
As expected, this graph seems to indicate that for multiple nodes, the size of the database makes a difference.
For some reason, the amount of data in the database did not seem to make a difference for the degenerate, 1-node case.
This makes sense because...additional nodes imply additional internode communications workload.
It may be worth noting that the pattern 1-node case seems to differ significantly from the pattern shown in \cite{Abramova2014TestingCassandra}'s Figure 3.  However, this may be due to the different domains: \cite{Abramova2014TestingCassandra} ranges in 1M, 10M, and 100M amounts of data, and this paper's Figure \ref{fig:wla} ranges in 500K, 800K, and 1M.

Execution time for Workload C...how did this compare to previous work?

\begin{figure}[h]
\includegraphics[width=15cm]{Figures/wlc.png}

\caption{Workload C: Reading Only}

\label{fig:wlc}
\end{figure}

More trials may be necessary here.  These results do not seem to correlate with either the work in \cite{Abramova2014TestingCassandra} nor the previous workload in Figure \ref{fig:wla}.
These results make it difficult to come to any conclusion.

Execution time for Workload E...how did this compare to previous work?

Execution time for loads...

By these tests, it would seem that Cassandra's scalability over node size for read-type workloads is limited, but more scalable for write-type workloads.

\section{Network configuration testing}

These results should show the differences between the variances in networking: nodal, wired \gls{lan}, and wireless \gls{lan}.

%\section{Experiment Set 1}

%The set-up follows the guidelines established in the methodology chapter \ref{Chapter3}.
%The set of experiments described in this section explored how Cassandra performs.
%Here a cluster of 3 Raspberry Pi 2 nodes was used.
%The tarball version of Cassandra version 3.9 was downloaded and installed.

%\subsection{Variance in Nature of the Links with Compression Algorithms}

%\begin{figure}[h]
%\includegraphics[width=15cm]{reworked_1.png}

%\caption{Varying Compression Methods: Writes}

%\label{fig:res}
%\end{figure}
%	The above box plot shows the effect of varying compression strategies for a given configuration on a pure write load as load-tested through the cassandra-stress module.  In the left, wireless 802.11 links were used.  On the right, wired Ethernet links were used.  A one-way analysis-of-variance (ANOVA) may be able to test whether there is a significant differential between either of these two means, but from visual inspection, one could say that for a given configuration and a write-heavy load, varying the compression strategy does not have a large effect on performance as far as writes per second.
%\begin{figure}[h]
%\includegraphics[width=15cm]{reworked_2.png}

%\caption{Varying Compression Methods: Reads}

%\label{fig:res}
%\end{figure}
%	To represent a read-heavy load, a pure read load was put through cassandra-stress, varying both compression strategies and wireless versus wired link nature.  In the wired domain (right), a hierarchy seems to emerge.  The LZ4 compression algorithm renders the most reads per second, followed by the Snappy compression algorithm, and finally the Deflation compression algorithm.  This correlates with the expectations put forth by the manual, as the selection in compression algorithms represents a trade-off between speed (operations per second) and compression effectiveness (storage in bytes) for the user.  Such a hierarchy does not seem to emerge from the wireless links, but there is no known explanation for this at this time.  Increased variation is not unexpected, perhaps due to \gls{ism} band interference, but one would expect the means to follow a similar pattern.  A series or regressions or multi-factor \gls{anova} test could be utilized to see if the graph is deceiving and the means truly are significantly different, but is not merited at this time.

%\begin{figure}[h]
%\includegraphics[width=15cm]{reworked_3.png}

%\caption{Compression Methods Sorted by Best Performance: Wired \gls{lan} Case}

%\label{fig:res}
%\end{figure}
%	The above box-plot shows, for wired, how performance can vary with respect to different compression strategies and loads.  For reads, the compression strategy hierarchy seems to correlate with what is expected from reading the manual: the LZ4 algorithm renders highest performance in operations per second, followed by the Snappy algorithm, then the Deflate algorithm.  For writes, the hierarchy continues but is less pronounced.  

%\begin{figure}[h]
%\includegraphics[width=15cm]{reworked_4.png}

%\caption{Compression Methods Sorted by Best Performance: Wireless \gls{lan} Case}

%\label{fig:res}
%\end{figure}

%	For the wireless links, the LZ4 algorithm seems to remain the highest performer, but the Deflate and Snappy algorithms seem to exchange places in the hierarchy, both for reads and for writes.  The means, shown as the dashed horizontal lines are very close together on both counts, so a hypothesis that the switch is not significant may be of merit.  The main thing that this graph shows is that at least in one test, the wireless links allowed for reasonably similar performance levels across compression strategies and loads.  To a potential application in the \gls{iot} domain, this may imply that one is not sacrificing much in the manner of operations per second by configuring Cassandra to employ a more effective compression strategy, such as the Deflate algorithm.
    

%\subsection{Variance in Compaction Strategies}

%Compaction strategies are discussed in section \ref{Cassandra Compaction} and in \cite{DatastaxCompactionSubproperties} and \cite{LeveledDataStax} \cite{DatastaxConfiguringCompaction}.
%According to \cite{DatastaxConfiguringCompaction}, Cassandra offers four (4) compaction strategies: \gls{stcs} (the default), \gls{dtcs}, \gls{twcs}, and \gls{lcs}.

%Varying the compaction strategy resulted in similar means, but no conclusion could be reached from the \gls{anova} test.

%For \gls{lcs} reads, varying the threshold size \gls{sstable}.

%$F_onewayResult(statistic=0.56902532143134721, pvalue=0.75515802456816006)$
%$LeveneResult(statistic=0.50007314283061954, pvalue=0.80851187861201057)$

%And likewise, for writes...

%$F_onewayResult(statistic=0.11330134854836313, pvalue=0.99488232126784426)$
%$LeveneResult(statistic=0.23240160884625752, pvalue=0.9660359170305548)$

%These results are inconclusive.

%\subsubsection{Write Path In Cassandra}


%These experiments aim to investigate the effect of varying among these strategies as well as the key subparameters that define them.


% * <richardson.dp@gmail.com> 2016-11-17T16:52:48.447Z:
%
% > \chapter{Cassandra Benchmark Study}
% > \label{Chapter4}
% > \label{Cassandra Benchmark Study}
% > \section{Experiment Set 1}
% > The set-up follows the guidelines established in the methodology chapter \ref{Chapter3}.
% > The set of experiments described in this section explored how Cassandra performs.
% > Here a cluster of 3 Raspberry Pi 2 nodes was used.
% > The tarball version of Cassandra version 3.9 was downloaded and installed.
% > \subsection{Variance in Nature of the Links with Compression Algorithms}
% > \begin{figure}[h]
% > \includegraphics[width=15cm]{reworked_1.png}
% > \caption{Varying Compression Methods: Writes}
% > \label{fig:res}
% > \end{figure}
% > 	The above box plot shows the effect of varying compression strategies for a given configuration on a pure write load as load-tested through the cassandra-stress module.  In the left, wireless 802.11 links were used.  On the right, wired Ethernet links were used.  A one-way analysis-of-variance (ANOVA) may be able to test whether there is a significant differential between either of these two means, but from visual inspection, one could say that for a given configuration and a write-heavy load, varying the compression strategy does not have a large effect on performance as far as writes per second.
% > \begin{figure}[h]
% > \includegraphics[width=15cm]{reworked_2.png}
% > \caption{Varying Compression Methods: Reads}
% > \label{fig:res}
% > \end{figure}
% > 	To represent a read-heavy load, a pure read load was put through cassandra-stress, varying both compression strategies and wireless versus wired link nature.  In the wired domain (right), a hierarchy seems to emerge.  The LZ4 compression algorithm renders the most reads per second, followed by the Snappy compression algorithm, and finally the Deflation compression algorithm.  This correlates with the expectations put forth by the manual, as the selection in compression algorithms represents a trade-off between speed (operations per second) and compression effectiveness (storage in bytes) for the user.  Such a hierarchy does not seem to emerge from the wireless links, but there is no known explanation for this at this time.  Increased variation is not unexpected, perhaps due to \gls{ism} band interference, but one would expect the means to follow a similar pattern.  A series or regressions or multi-factor \gls{anova} test could be utilized to see if the graph is deceiving and the means truly are significantly different, but is not merited at this time.
% > \begin{figure}[h]
% > \includegraphics[width=15cm]{reworked_3.png}
% > \caption{Compression Methods Sorted by Best Performance: Wired \gls{lan} Case}
% > \label{fig:res}
% > \end{figure}
% > 	The above box-plot shows, for wired, how performance can vary with respect to different compression strategies and loads.  For reads, the compression strategy hierarchy seems to correlate with what is expected from reading the manual: the LZ4 algorithm renders highest performance in operations per second, followed by the Snappy algorithm, then the Deflate algorithm.  For writes, the hierarchy continues but is less pronounced.  
% > \begin{figure}[h]
% > \includegraphics[width=15cm]{reworked_4.png}
% > \caption{Compression Methods Sorted by Best Performance: Wireless \gls{lan} Case}
% > \label{fig:res}
% > \end{figure}
% > 	For the wireless links, the LZ4 algorithm seems to remain the highest performer, but the Deflate and Snappy algorithms seem to exchange places in the hierarchy, both for reads and for writes.  The means, shown as the dashed horizontal lines are very close together on both counts, so a hypothesis that the switch is not significant may be of merit.  The main thing that this graph shows is that at least in one test, the wireless links allowed for reasonably similar performance levels across compression strategies and loads.  To a potential application in the \gls{iot} domain, this may imply that one is not sacrificing much in the manner of operations per second by configuring Cassandra to employ a more effective compression strategy, such as the Deflate algorithm.
% >     
% > \subsection{Variance in Compaction Strategies}
% > Compaction strategies are discussed in section \ref{Cassandra Compaction} and in \cite{DatastaxCompactionSubproperties} and \cite{LeveledDataStax} \cite{DatastaxConfiguringCompaction}.
% > According to \cite{DatastaxConfiguringCompaction}, Cassandra offers four (4) compaction strategies: \gls{stcs} (the default), \gls{dtcs}, \gls{twcs}, and \gls{lcs}.
% > Varying the compaction strategy resulted in similar means, but no conclusion could be reached from the \gls{anova} test.
% > For \gls{lcs} reads, varying the threshold size \gls{sstable}.
% > $F_onewayResult(statistic=0.56902532143134721, pvalue=0.75515802456816006)$
% > $LeveneResult(statistic=0.50007314283061954, pvalue=0.80851187861201057)$
% > And likewise, for writes...
% > $F_onewayResult(statistic=0.11330134854836313, pvalue=0.99488232126784426)$
% > $LeveneResult(statistic=0.23240160884625752, pvalue=0.9660359170305548)$
% > These results are inconclusive.
% > \subsubsection{Write Path In Cassandra}
% > These experiments aim to investigate the effect of varying among these strategies as well as the key subparameters that define them.
%
% ^.